// CardService.swift
// Service for SmartPGP card operations

import Foundation

/// Service for SmartPGP card management operations
class CardService {

    /// Execute a GPG command and return the output
    private func executeGPG(_ command: String, input: String? = nil, timeout: TimeInterval = 30) throws -> (output: String, error: String, exitCode: Int32) {
        let process = Process()
        process.executableURL = URL(fileURLWithPath: "/usr/bin/env")
        process.arguments = ["bash", "-c", command]

        let outputPipe = Pipe()
        let errorPipe = Pipe()
        let inputPipe = Pipe()

        process.standardOutput = outputPipe
        process.standardError = errorPipe
        process.standardInput = inputPipe

        try process.run()

        // Write input if provided
        if let input = input {
            if let data = input.data(using: .utf8) {
                inputPipe.fileHandleForWriting.write(data)
            }
            try? inputPipe.fileHandleForWriting.close()
        }

        // Wait for completion with timeout
        let startTime = Date()
        while process.isRunning && Date().timeIntervalSince(startTime) < timeout {
            Thread.sleep(forTimeInterval: 0.1)
        }

        if process.isRunning {
            process.terminate()
            throw CardError.timeout("Command timed out after \(timeout) seconds")
        }

        let outputData = outputPipe.fileHandleForReading.readDataToEndOfFile()
        let errorData = errorPipe.fileHandleForReading.readDataToEndOfFile()

        let output = String(data: outputData, encoding: .utf8) ?? ""
        let error = String(data: errorData, encoding: .utf8) ?? ""

        return (output: output, error: error, exitCode: process.terminationStatus)
    }

    /// Generate a new RSA keypair on the card
    func generateKeypair(keySize: Int = 2048, adminPin: String = "12345678") throws -> GenerateKeypairResponse {
        // Verify card is present
        let (cardOutput, _, cardExitCode) = try executeGPG("gpg --card-status")
        guard cardExitCode == 0 else {
            throw CardError.cardNotFound("SmartPGP card not detected")
        }

        // Check if card has SmartPGP applet
        guard cardOutput.contains("Application ID") || cardOutput.contains("Reader") else {
            throw CardError.invalidCard("No valid OpenPGP card found")
        }

        // Generate keypair using GPG
        // Note: This uses GPG's admin commands to generate keys on the card
        let gpgCommands = """
        admin
        generate
        n
        \(adminPin)
        \(adminPin)
        0
        SmartPGP User
        smartpgp@example.com
        Generated by SmartPGP Helper
        o
        quit
        """

        let (output, error, exitCode) = try executeGPG("gpg --command-fd 0 --status-fd 2 --card-edit",
                                                         input: gpgCommands,
                                                         timeout: 120)

        if exitCode != 0 {
            throw CardError.keyGenerationFailed("Key generation failed: \(error)")
        }

        // Extract key information from output
        let keyId = extractKeyId(from: output + error)

        return GenerateKeypairResponse(
            success: true,
            message: "RSA-\(keySize) keypair generated successfully on card",
            keyId: keyId
        )
    }

    /// Change the user PIN on the card
    func changePin(currentPin: String, newPin: String) throws -> ChangePinResponse {
        // Validate PIN lengths
        guard newPin.count >= 6 && newPin.count <= 127 else {
            throw CardError.invalidPin("PIN must be between 6 and 127 characters")
        }

        // Use GPG passwd command to change PIN
        let gpgCommands = """
        admin
        passwd
        1
        \(currentPin)
        \(newPin)
        \(newPin)
        quit
        """

        let (output, error, exitCode) = try executeGPG("gpg --command-fd 0 --status-fd 2 --card-edit",
                                                         input: gpgCommands,
                                                         timeout: 30)

        // Check for success indicators
        let combined = output + error
        if combined.contains("PIN changed") || combined.contains("succeeded") || exitCode == 0 {
            // Kill GPG agent to release card
            _ = try? executeGPG("gpgconf --kill gpg-agent")
            Thread.sleep(forTimeInterval: 0.5)

            // Verify new PIN works
            let verifyResult = try executeGPG("gpg --command-fd 0 --card-status",
                                              input: "\(newPin)\n")

            return ChangePinResponse(
                success: true,
                message: "PIN changed successfully"
            )
        }

        // Check for specific error cases
        if combined.contains("Bad PIN") || combined.contains("incorrect") {
            throw CardError.incorrectPin("Current PIN is incorrect")
        }

        throw CardError.pinChangeFailed("PIN change failed: \(error)")
    }

    /// Delete all keys from the card (factory reset)
    func deleteKeypair(adminPin: String = "12345678") throws -> DeleteKeypairResponse {
        // Use GPG factory-reset command
        let gpgCommands = """
        admin
        factory-reset
        yes
        yes
        quit
        """

        let (output, error, exitCode) = try executeGPG("gpg --command-fd 0 --status-fd 2 --card-edit",
                                                         input: gpgCommands,
                                                         timeout: 30)

        // Kill GPG agent to release card
        _ = try? executeGPG("gpgconf --kill gpg-agent")
        _ = try? executeGPG("gpgconf --kill scdaemon")
        Thread.sleep(forTimeInterval: 1.0)

        let combined = output + error
        if combined.contains("reset") || combined.contains("factory") || exitCode == 0 {
            return DeleteKeypairResponse(
                success: true,
                message: "Card reset to factory defaults. Default PIN: 123456, Admin PIN: 12345678"
            )
        }

        throw CardError.deleteFailed("Factory reset failed: \(error)")
    }

    /// Get card status information
    func getCardStatus() throws -> CardStatusResponse {
        let (output, error, exitCode) = try executeGPG("gpg --card-status")

        guard exitCode == 0 else {
            throw CardError.cardNotFound("Cannot read card status: \(error)")
        }

        // Parse card status
        let hasSignKey = output.contains("Signature key")
        let hasEncKey = output.contains("Encryption key") || output.contains("General key")
        let hasAuthKey = output.contains("Authentication key")

        // Extract serial number
        var serialNumber: String?
        if let range = output.range(of: "Serial number .* ([0-9A-F]+)", options: .regularExpression) {
            serialNumber = String(output[range])
        }

        return CardStatusResponse(
            cardPresent: true,
            hasSigningKey: hasSignKey,
            hasEncryptionKey: hasEncKey,
            hasAuthenticationKey: hasAuthKey,
            serialNumber: serialNumber,
            rawStatus: output
        )
    }

    /// Helper to extract key ID from GPG output
    private func extractKeyId(from output: String) -> String? {
        // Look for key ID patterns in GPG output
        let patterns = [
            #"key ([0-9A-F]{8,16})"#,
            #"KEY_CREATED [SP] ([0-9A-F]{40})"#,
            #"fingerprint: ([0-9A-F\s]+)"#
        ]

        for pattern in patterns {
            if let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive),
               let match = regex.firstMatch(in: output, range: NSRange(output.startIndex..., in: output)),
               let range = Range(match.range(at: 1), in: output) {
                return String(output[range]).replacingOccurrences(of: " ", with: "")
            }
        }

        return nil
    }
}

// MARK: - Response Models

struct GenerateKeypairResponse: Codable {
    let success: Bool
    let message: String
    let keyId: String?
}

struct ChangePinResponse: Codable {
    let success: Bool
    let message: String
}

struct DeleteKeypairResponse: Codable {
    let success: Bool
    let message: String
}

struct CardStatusResponse: Codable {
    let cardPresent: Bool
    let hasSigningKey: Bool
    let hasEncryptionKey: Bool
    let hasAuthenticationKey: Bool
    let serialNumber: String?
    let rawStatus: String
}

// MARK: - Errors

enum CardError: Error, CustomStringConvertible {
    case cardNotFound(String)
    case invalidCard(String)
    case keyGenerationFailed(String)
    case invalidPin(String)
    case incorrectPin(String)
    case pinChangeFailed(String)
    case deleteFailed(String)
    case timeout(String)

    var description: String {
        switch self {
        case .cardNotFound(let msg): return "Card not found: \(msg)"
        case .invalidCard(let msg): return "Invalid card: \(msg)"
        case .keyGenerationFailed(let msg): return "Key generation failed: \(msg)"
        case .invalidPin(let msg): return "Invalid PIN: \(msg)"
        case .incorrectPin(let msg): return "Incorrect PIN: \(msg)"
        case .pinChangeFailed(let msg): return "PIN change failed: \(msg)"
        case .deleteFailed(let msg): return "Delete failed: \(msg)"
        case .timeout(let msg): return "Timeout: \(msg)"
        }
    }
}
